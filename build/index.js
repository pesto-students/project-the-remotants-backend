!function(e){var r={};function t(n){if(r[n])return r[n].exports;var s=r[n]={i:n,l:!1,exports:{}};return e[n].call(s.exports,s,s.exports,t),s.l=!0,s.exports}t.m=e,t.c=r,t.d=function(e,r,n){t.o(e,r)||Object.defineProperty(e,r,{enumerable:!0,get:n})},t.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},t.t=function(e,r){if(1&r&&(e=t(e)),8&r)return e;if(4&r&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(t.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&r&&"string"!=typeof e)for(var s in e)t.d(n,s,function(r){return e[r]}.bind(null,s));return n},t.n=function(e){var r=e&&e.__esModule?function(){return e.default}:function(){return e};return t.d(r,"a",r),r},t.o=function(e,r){return Object.prototype.hasOwnProperty.call(e,r)},t.p="",t(t.s=11)}([function(e,r){e.exports=require("express")},function(e,r){e.exports=require("bcrypt")},function(e,r){e.exports=require("jsonwebtoken")},function(e,r){e.exports=require("body-parser")},function(e,r){e.exports=require("lodash/isEmpty")},function(e,r){e.exports=require("validator")},function(e,r){e.exports=require("dotenv")},function(e,r){e.exports=require("mongodb")},function(e,r){e.exports=require("shortid")},function(e,r){e.exports=require("cors")},function(e,r){e.exports=require("morgan")},function(e,r,t){"use strict";t.r(r);var n=t(0),s=t.n(n),a=t(10),o=t.n(a),i=t(9),c=t.n(i),u=t(3),l=t(8),d=t.n(l),f=t(7),p=t(6);t.n(p).a.config();const{DB_URL:m,DB_NAME:y,USERS_COLLECTION:w,TEST_DB_URL:g,TEST_DB_NAME:h,TEST_USERS_COLLECTION:E,SECRET:O,SALT_ROUNDS:v}=process.env,S={DB_URL:m,DB_NAME:y,USERS_COLLECTION:w,SECRET:O,SALT_ROUNDS:v,ONE_DAY:604800,PORT:process.env.PORT||8e3},_=S.DB_URL,{DB_NAME:b}=S;let R;const T=async()=>{if(await(async()=>(void 0===R&&(R=await f.MongoClient.connect(_,{useNewUrlParser:!0})),R))(),void 0===R)throw new Error("No connection instance present");return R.db(b)};var C=t(2),x=t.n(C),j=t(1),L=t.n(j);var N=t(5),U=t.n(N),D=t(4),P=t.n(D);var q={validateInput:e=>{const{email:r}=e,t={};return U.a.isEmail(r)||(t.name="Email is invalid"),{errors:t,isValid:P()(t)}}};const A=s.a.Router(),I=async(e,r,{id:t,email:n,password:s})=>{try{const a=await(async e=>{return await L.a.hash(e,+S.SALT_ROUNDS)})(s);return await e.collection(r).insertOne({id:t,email:n,password:a}),{success:!0}}catch(e){return{errors:{name:"[Register]: Caught an error while adding user to the Database."}}}},M=async(e,r,{email:t,password:n})=>{try{const s=await e.collection(r).findOne({email:t});if(null===s)return{errors:{name:"Email entered is incorrect"}};const a=s.password;return!1===await(async(e,r)=>{return await L.a.compare(e,r)})(n,a)?{errors:{name:"Password entered is incorrect"}}:{success:!0,token:(e=>{return x.a.sign({email:e},S.SECRET,{expiresIn:Math.floor((new Date).getTime()/1e3)+ +S.ONE_DAY})})(s.email)}}catch(e){return{errors:{name:"[Login]: Caught an error while getting user from the database."}}}};A.post("/register",async(e,r)=>{const t=await T(),n=S.USERS_COLLECTION,s=e.body,{errors:a,isValid:o}=q.validateInput(s);if(o){const e=d.a.generate().toLowerCase(),a=await(async(e,r,{id:t,email:n,password:s})=>{try{return 0===await e.collection(r).count({email:n})?await I(e,r,{id:t,email:n,password:s}):{errors:{name:"User exists"}}}catch(e){return{errors:{name:"[Register]: Caught an error while registering user."}}}})(t,n,{...s,id:e});r.json(a)}else r.json({errors:a})}),A.post("/login",async(e,r)=>{const t=await T(),n=S.USERS_COLLECTION,s=e.body,{errors:a,isValid:o}=q.validateInput(s);if(o){const e=await M(t,n,s);r.json(e)}else r.json({errors:a})});var B=A;var k=async(e,r,t)=>{try{return 0===await e.collection(r).count({username:t})?{success:!0}:{errors:{name:"Username already exists"}}}catch(e){return{errors:{name:"Caught an error while finding if username exists or not"}}}};const V=s.a.Router();V.use(async(e,r,t)=>{const n=e.headers.authorization;let s;if(n&&([,s]=n.split(" ")),s)try{const{success:n,user:a,errors:o}=await(async e=>await x.a.verify(e,S.SECRET,async(e,r)=>{if(e)return{errors:{name:`Failed to authenticate: ${e}`}};const{email:t}=r,n=await T();try{const e=await(async(e,r,t)=>{try{const n=await e.collection(r).find({email:t}).project({_id:0,id:1,email:1}).toArray(),[s]=n;return null===s?null:s}catch(e){return null}})(n,"users",t);return null===e?{errors:{name:"No such user"}}:{success:!0,user:e}}catch(e){return{errors:{name:"Caught an error while checking if the user exists or not."}}}}))(s);!0===n?(e.currentUser=a.email,t()):r.json(o)}catch(e){r.json({errors:{name:"Caught an error at the time of verifying token."}})}else r.json({errors:{name:"No token provided"}})});V.get("/",(e,r)=>{r.json({success:!0})}),V.post("/setup",async(e,r)=>{const{currentUser:t}=e,n=await T(),s=S.USERS_COLLECTION,a=await(async(e,r,t,n)=>{const{name:s,dob:a,username:o}=n,i=await k(e,r,o);if(!0!==i.success)return i;try{return await e.collection(r).update({email:t},{$set:{name:s,dob:a,username:o}}),{success:!0}}catch(e){return{errors:{name:"[Register]: Caught an error while updating user details."}}}})(n,s,t,e.body);r.json(a)});var $=V;const Y=s()();Y.use(o()("dev")),Y.use(c()()),Y.use(Object(u.json)()),Y.use(Object(u.urlencoded)({extended:!0})),Y.use("/auth",B),Y.use("/dashboard",$),Y.get("/",(e,r)=>{r.send("Roll over to /test to see it it's working or not")}),Y.get("/test",(e,r)=>{r.json({status:"Working!"})});const z=Y.listen(S.PORT,()=>{console.log(`Backend is running on PORT: ${S.PORT}`)});r.default=z}]);